

package com.mapbox.services.android.navigation.v5.routeprogress;

import androidx.annotation.Nullable;
import androidx.core.util.Pair;
import com.mapbox.api.directions.v5.models.RouteLeg;
import com.mapbox.api.directions.v5.models.StepIntersection;
import com.mapbox.geojson.Point;
import java.util.List;

// Generated by com.google.auto.value.processor.AutoValueProcessor
 final class AutoValue_RouteLegProgress extends RouteLegProgress {

  private final int stepIndex;
  private final double distanceRemaining;
  private final RouteStepProgress currentStepProgress;
  private final List<Point> currentStepPoints;
  private final List<Point> upcomingStepPoints;
  private final CurrentLegAnnotation currentLegAnnotation;
  private final RouteLeg routeLeg;
  private final double stepDistanceRemaining;
  private final List<StepIntersection> intersections;
  private final StepIntersection currentIntersection;
  private final StepIntersection upcomingIntersection;
  private final List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep;

  private AutoValue_RouteLegProgress(
      int stepIndex,
      double distanceRemaining,
      RouteStepProgress currentStepProgress,
      List<Point> currentStepPoints,
      @Nullable List<Point> upcomingStepPoints,
      @Nullable CurrentLegAnnotation currentLegAnnotation,
      RouteLeg routeLeg,
      double stepDistanceRemaining,
      List<StepIntersection> intersections,
      StepIntersection currentIntersection,
      @Nullable StepIntersection upcomingIntersection,
      List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep) {
    this.stepIndex = stepIndex;
    this.distanceRemaining = distanceRemaining;
    this.currentStepProgress = currentStepProgress;
    this.currentStepPoints = currentStepPoints;
    this.upcomingStepPoints = upcomingStepPoints;
    this.currentLegAnnotation = currentLegAnnotation;
    this.routeLeg = routeLeg;
    this.stepDistanceRemaining = stepDistanceRemaining;
    this.intersections = intersections;
    this.currentIntersection = currentIntersection;
    this.upcomingIntersection = upcomingIntersection;
    this.intersectionDistancesAlongStep = intersectionDistancesAlongStep;
  }

  @Override
  public int stepIndex() {
    return stepIndex;
  }

  @Override
  public double distanceRemaining() {
    return distanceRemaining;
  }

  @Override
  public RouteStepProgress currentStepProgress() {
    return currentStepProgress;
  }

  @Override
  public List<Point> currentStepPoints() {
    return currentStepPoints;
  }

  @Nullable
  @Override
  public List<Point> upcomingStepPoints() {
    return upcomingStepPoints;
  }

  @Nullable
  @Override
  public CurrentLegAnnotation currentLegAnnotation() {
    return currentLegAnnotation;
  }

  @Override
  RouteLeg routeLeg() {
    return routeLeg;
  }

  @Override
  double stepDistanceRemaining() {
    return stepDistanceRemaining;
  }

  @Override
  List<StepIntersection> intersections() {
    return intersections;
  }

  @Override
  StepIntersection currentIntersection() {
    return currentIntersection;
  }

  @Nullable
  @Override
  StepIntersection upcomingIntersection() {
    return upcomingIntersection;
  }

  @Override
  List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep() {
    return intersectionDistancesAlongStep;
  }

  @Override
  public String toString() {
    return "RouteLegProgress{"
         + "stepIndex=" + stepIndex + ", "
         + "distanceRemaining=" + distanceRemaining + ", "
         + "currentStepProgress=" + currentStepProgress + ", "
         + "currentStepPoints=" + currentStepPoints + ", "
         + "upcomingStepPoints=" + upcomingStepPoints + ", "
         + "currentLegAnnotation=" + currentLegAnnotation + ", "
         + "routeLeg=" + routeLeg + ", "
         + "stepDistanceRemaining=" + stepDistanceRemaining + ", "
         + "intersections=" + intersections + ", "
         + "currentIntersection=" + currentIntersection + ", "
         + "upcomingIntersection=" + upcomingIntersection + ", "
         + "intersectionDistancesAlongStep=" + intersectionDistancesAlongStep
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof RouteLegProgress) {
      RouteLegProgress that = (RouteLegProgress) o;
      return (this.stepIndex == that.stepIndex())
           && (Double.doubleToLongBits(this.distanceRemaining) == Double.doubleToLongBits(that.distanceRemaining()))
           && (this.currentStepProgress.equals(that.currentStepProgress()))
           && (this.currentStepPoints.equals(that.currentStepPoints()))
           && ((this.upcomingStepPoints == null) ? (that.upcomingStepPoints() == null) : this.upcomingStepPoints.equals(that.upcomingStepPoints()))
           && ((this.currentLegAnnotation == null) ? (that.currentLegAnnotation() == null) : this.currentLegAnnotation.equals(that.currentLegAnnotation()))
           && (this.routeLeg.equals(that.routeLeg()))
           && (Double.doubleToLongBits(this.stepDistanceRemaining) == Double.doubleToLongBits(that.stepDistanceRemaining()))
           && (this.intersections.equals(that.intersections()))
           && (this.currentIntersection.equals(that.currentIntersection()))
           && ((this.upcomingIntersection == null) ? (that.upcomingIntersection() == null) : this.upcomingIntersection.equals(that.upcomingIntersection()))
           && (this.intersectionDistancesAlongStep.equals(that.intersectionDistancesAlongStep()));
    }
    return false;
  }

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= stepIndex;
    h$ *= 1000003;
    h$ ^= (int) ((Double.doubleToLongBits(distanceRemaining) >>> 32) ^ Double.doubleToLongBits(distanceRemaining));
    h$ *= 1000003;
    h$ ^= currentStepProgress.hashCode();
    h$ *= 1000003;
    h$ ^= currentStepPoints.hashCode();
    h$ *= 1000003;
    h$ ^= (upcomingStepPoints == null) ? 0 : upcomingStepPoints.hashCode();
    h$ *= 1000003;
    h$ ^= (currentLegAnnotation == null) ? 0 : currentLegAnnotation.hashCode();
    h$ *= 1000003;
    h$ ^= routeLeg.hashCode();
    h$ *= 1000003;
    h$ ^= (int) ((Double.doubleToLongBits(stepDistanceRemaining) >>> 32) ^ Double.doubleToLongBits(stepDistanceRemaining));
    h$ *= 1000003;
    h$ ^= intersections.hashCode();
    h$ *= 1000003;
    h$ ^= currentIntersection.hashCode();
    h$ *= 1000003;
    h$ ^= (upcomingIntersection == null) ? 0 : upcomingIntersection.hashCode();
    h$ *= 1000003;
    h$ ^= intersectionDistancesAlongStep.hashCode();
    return h$;
  }

  static final class Builder extends RouteLegProgress.Builder {
    private Integer stepIndex;
    private Double distanceRemaining;
    private RouteStepProgress currentStepProgress;
    private List<Point> currentStepPoints;
    private List<Point> upcomingStepPoints;
    private CurrentLegAnnotation currentLegAnnotation;
    private RouteLeg routeLeg;
    private Double stepDistanceRemaining;
    private List<StepIntersection> intersections;
    private StepIntersection currentIntersection;
    private StepIntersection upcomingIntersection;
    private List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep;
    Builder() {
    }
    @Override
    RouteLegProgress.Builder stepIndex(int stepIndex) {
      this.stepIndex = stepIndex;
      return this;
    }
    @Override
    int stepIndex() {
      if (stepIndex == null) {
        throw new IllegalStateException("Property \"stepIndex\" has not been set");
      }
      return stepIndex;
    }
    @Override
    RouteLegProgress.Builder distanceRemaining(double distanceRemaining) {
      this.distanceRemaining = distanceRemaining;
      return this;
    }
    @Override
    RouteLegProgress.Builder currentStepProgress(RouteStepProgress currentStepProgress) {
      if (currentStepProgress == null) {
        throw new NullPointerException("Null currentStepProgress");
      }
      this.currentStepProgress = currentStepProgress;
      return this;
    }
    @Override
    RouteLegProgress.Builder currentStepPoints(List<Point> currentStepPoints) {
      if (currentStepPoints == null) {
        throw new NullPointerException("Null currentStepPoints");
      }
      this.currentStepPoints = currentStepPoints;
      return this;
    }
    @Override
    RouteLegProgress.Builder upcomingStepPoints(@Nullable List<Point> upcomingStepPoints) {
      this.upcomingStepPoints = upcomingStepPoints;
      return this;
    }
    @Override
    RouteLegProgress.Builder currentLegAnnotation(@Nullable CurrentLegAnnotation currentLegAnnotation) {
      this.currentLegAnnotation = currentLegAnnotation;
      return this;
    }
    @Override
    RouteLegProgress.Builder routeLeg(RouteLeg routeLeg) {
      if (routeLeg == null) {
        throw new NullPointerException("Null routeLeg");
      }
      this.routeLeg = routeLeg;
      return this;
    }
    @Override
    RouteLeg routeLeg() {
      if (routeLeg == null) {
        throw new IllegalStateException("Property \"routeLeg\" has not been set");
      }
      return routeLeg;
    }
    @Override
    RouteLegProgress.Builder stepDistanceRemaining(double stepDistanceRemaining) {
      this.stepDistanceRemaining = stepDistanceRemaining;
      return this;
    }
    @Override
    double stepDistanceRemaining() {
      if (stepDistanceRemaining == null) {
        throw new IllegalStateException("Property \"stepDistanceRemaining\" has not been set");
      }
      return stepDistanceRemaining;
    }
    @Override
    RouteLegProgress.Builder intersections(List<StepIntersection> intersections) {
      if (intersections == null) {
        throw new NullPointerException("Null intersections");
      }
      this.intersections = intersections;
      return this;
    }
    @Override
    List<StepIntersection> intersections() {
      if (intersections == null) {
        throw new IllegalStateException("Property \"intersections\" has not been set");
      }
      return intersections;
    }
    @Override
    RouteLegProgress.Builder currentIntersection(StepIntersection currentIntersection) {
      if (currentIntersection == null) {
        throw new NullPointerException("Null currentIntersection");
      }
      this.currentIntersection = currentIntersection;
      return this;
    }
    @Override
    StepIntersection currentIntersection() {
      if (currentIntersection == null) {
        throw new IllegalStateException("Property \"currentIntersection\" has not been set");
      }
      return currentIntersection;
    }
    @Override
    RouteLegProgress.Builder upcomingIntersection(@Nullable StepIntersection upcomingIntersection) {
      this.upcomingIntersection = upcomingIntersection;
      return this;
    }
    @Override
    @Nullable StepIntersection upcomingIntersection() {
      return upcomingIntersection;
    }
    @Override
    RouteLegProgress.Builder intersectionDistancesAlongStep(List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep) {
      if (intersectionDistancesAlongStep == null) {
        throw new NullPointerException("Null intersectionDistancesAlongStep");
      }
      this.intersectionDistancesAlongStep = intersectionDistancesAlongStep;
      return this;
    }
    @Override
    List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep() {
      if (intersectionDistancesAlongStep == null) {
        throw new IllegalStateException("Property \"intersectionDistancesAlongStep\" has not been set");
      }
      return intersectionDistancesAlongStep;
    }
    @Override
    RouteLegProgress autoBuild() {
      String missing = "";
      if (this.stepIndex == null) {
        missing += " stepIndex";
      }
      if (this.distanceRemaining == null) {
        missing += " distanceRemaining";
      }
      if (this.currentStepProgress == null) {
        missing += " currentStepProgress";
      }
      if (this.currentStepPoints == null) {
        missing += " currentStepPoints";
      }
      if (this.routeLeg == null) {
        missing += " routeLeg";
      }
      if (this.stepDistanceRemaining == null) {
        missing += " stepDistanceRemaining";
      }
      if (this.intersections == null) {
        missing += " intersections";
      }
      if (this.currentIntersection == null) {
        missing += " currentIntersection";
      }
      if (this.intersectionDistancesAlongStep == null) {
        missing += " intersectionDistancesAlongStep";
      }
      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new AutoValue_RouteLegProgress(
          this.stepIndex,
          this.distanceRemaining,
          this.currentStepProgress,
          this.currentStepPoints,
          this.upcomingStepPoints,
          this.currentLegAnnotation,
          this.routeLeg,
          this.stepDistanceRemaining,
          this.intersections,
          this.currentIntersection,
          this.upcomingIntersection,
          this.intersectionDistancesAlongStep);
    }
  }

}
