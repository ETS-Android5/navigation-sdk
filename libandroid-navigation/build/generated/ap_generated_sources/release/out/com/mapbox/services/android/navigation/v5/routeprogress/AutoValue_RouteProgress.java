

package com.mapbox.services.android.navigation.v5.routeprogress;

import androidx.annotation.Nullable;
import androidx.core.util.Pair;
import com.mapbox.api.directions.v5.models.DirectionsRoute;
import com.mapbox.api.directions.v5.models.StepIntersection;
import com.mapbox.geojson.Point;
import java.util.List;

// Generated by com.google.auto.value.processor.AutoValueProcessor
 final class AutoValue_RouteProgress extends RouteProgress {

  private final DirectionsRoute directionsRoute;
  private final int legIndex;
  private final double distanceRemaining;
  private final RouteLegProgress currentLegProgress;
  private final List<Point> currentStepPoints;
  private final List<Point> upcomingStepPoints;
  private final int stepIndex;
  private final double legDistanceRemaining;
  private final double stepDistanceRemaining;
  private final List<StepIntersection> intersections;
  private final StepIntersection currentIntersection;
  private final StepIntersection upcomingIntersection;
  private final CurrentLegAnnotation currentLegAnnotation;
  private final List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep;

  private AutoValue_RouteProgress(
      DirectionsRoute directionsRoute,
      int legIndex,
      double distanceRemaining,
      RouteLegProgress currentLegProgress,
      List<Point> currentStepPoints,
      @Nullable List<Point> upcomingStepPoints,
      int stepIndex,
      double legDistanceRemaining,
      double stepDistanceRemaining,
      List<StepIntersection> intersections,
      StepIntersection currentIntersection,
      @Nullable StepIntersection upcomingIntersection,
      @Nullable CurrentLegAnnotation currentLegAnnotation,
      List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep) {
    this.directionsRoute = directionsRoute;
    this.legIndex = legIndex;
    this.distanceRemaining = distanceRemaining;
    this.currentLegProgress = currentLegProgress;
    this.currentStepPoints = currentStepPoints;
    this.upcomingStepPoints = upcomingStepPoints;
    this.stepIndex = stepIndex;
    this.legDistanceRemaining = legDistanceRemaining;
    this.stepDistanceRemaining = stepDistanceRemaining;
    this.intersections = intersections;
    this.currentIntersection = currentIntersection;
    this.upcomingIntersection = upcomingIntersection;
    this.currentLegAnnotation = currentLegAnnotation;
    this.intersectionDistancesAlongStep = intersectionDistancesAlongStep;
  }

  @Override
  public DirectionsRoute directionsRoute() {
    return directionsRoute;
  }

  @Override
  public int legIndex() {
    return legIndex;
  }

  @Override
  public double distanceRemaining() {
    return distanceRemaining;
  }

  @Override
  public RouteLegProgress currentLegProgress() {
    return currentLegProgress;
  }

  @Override
  public List<Point> currentStepPoints() {
    return currentStepPoints;
  }

  @Nullable
  @Override
  public List<Point> upcomingStepPoints() {
    return upcomingStepPoints;
  }

  @Override
  int stepIndex() {
    return stepIndex;
  }

  @Override
  double legDistanceRemaining() {
    return legDistanceRemaining;
  }

  @Override
  double stepDistanceRemaining() {
    return stepDistanceRemaining;
  }

  @Override
  List<StepIntersection> intersections() {
    return intersections;
  }

  @Override
  StepIntersection currentIntersection() {
    return currentIntersection;
  }

  @Nullable
  @Override
  StepIntersection upcomingIntersection() {
    return upcomingIntersection;
  }

  @Nullable
  @Override
  CurrentLegAnnotation currentLegAnnotation() {
    return currentLegAnnotation;
  }

  @Override
  List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep() {
    return intersectionDistancesAlongStep;
  }

  @Override
  public String toString() {
    return "RouteProgress{"
         + "directionsRoute=" + directionsRoute + ", "
         + "legIndex=" + legIndex + ", "
         + "distanceRemaining=" + distanceRemaining + ", "
         + "currentLegProgress=" + currentLegProgress + ", "
         + "currentStepPoints=" + currentStepPoints + ", "
         + "upcomingStepPoints=" + upcomingStepPoints + ", "
         + "stepIndex=" + stepIndex + ", "
         + "legDistanceRemaining=" + legDistanceRemaining + ", "
         + "stepDistanceRemaining=" + stepDistanceRemaining + ", "
         + "intersections=" + intersections + ", "
         + "currentIntersection=" + currentIntersection + ", "
         + "upcomingIntersection=" + upcomingIntersection + ", "
         + "currentLegAnnotation=" + currentLegAnnotation + ", "
         + "intersectionDistancesAlongStep=" + intersectionDistancesAlongStep
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof RouteProgress) {
      RouteProgress that = (RouteProgress) o;
      return (this.directionsRoute.equals(that.directionsRoute()))
           && (this.legIndex == that.legIndex())
           && (Double.doubleToLongBits(this.distanceRemaining) == Double.doubleToLongBits(that.distanceRemaining()))
           && (this.currentLegProgress.equals(that.currentLegProgress()))
           && (this.currentStepPoints.equals(that.currentStepPoints()))
           && ((this.upcomingStepPoints == null) ? (that.upcomingStepPoints() == null) : this.upcomingStepPoints.equals(that.upcomingStepPoints()))
           && (this.stepIndex == that.stepIndex())
           && (Double.doubleToLongBits(this.legDistanceRemaining) == Double.doubleToLongBits(that.legDistanceRemaining()))
           && (Double.doubleToLongBits(this.stepDistanceRemaining) == Double.doubleToLongBits(that.stepDistanceRemaining()))
           && (this.intersections.equals(that.intersections()))
           && (this.currentIntersection.equals(that.currentIntersection()))
           && ((this.upcomingIntersection == null) ? (that.upcomingIntersection() == null) : this.upcomingIntersection.equals(that.upcomingIntersection()))
           && ((this.currentLegAnnotation == null) ? (that.currentLegAnnotation() == null) : this.currentLegAnnotation.equals(that.currentLegAnnotation()))
           && (this.intersectionDistancesAlongStep.equals(that.intersectionDistancesAlongStep()));
    }
    return false;
  }

  @Override
  public int hashCode() {
    int h$ = 1;
    h$ *= 1000003;
    h$ ^= directionsRoute.hashCode();
    h$ *= 1000003;
    h$ ^= legIndex;
    h$ *= 1000003;
    h$ ^= (int) ((Double.doubleToLongBits(distanceRemaining) >>> 32) ^ Double.doubleToLongBits(distanceRemaining));
    h$ *= 1000003;
    h$ ^= currentLegProgress.hashCode();
    h$ *= 1000003;
    h$ ^= currentStepPoints.hashCode();
    h$ *= 1000003;
    h$ ^= (upcomingStepPoints == null) ? 0 : upcomingStepPoints.hashCode();
    h$ *= 1000003;
    h$ ^= stepIndex;
    h$ *= 1000003;
    h$ ^= (int) ((Double.doubleToLongBits(legDistanceRemaining) >>> 32) ^ Double.doubleToLongBits(legDistanceRemaining));
    h$ *= 1000003;
    h$ ^= (int) ((Double.doubleToLongBits(stepDistanceRemaining) >>> 32) ^ Double.doubleToLongBits(stepDistanceRemaining));
    h$ *= 1000003;
    h$ ^= intersections.hashCode();
    h$ *= 1000003;
    h$ ^= currentIntersection.hashCode();
    h$ *= 1000003;
    h$ ^= (upcomingIntersection == null) ? 0 : upcomingIntersection.hashCode();
    h$ *= 1000003;
    h$ ^= (currentLegAnnotation == null) ? 0 : currentLegAnnotation.hashCode();
    h$ *= 1000003;
    h$ ^= intersectionDistancesAlongStep.hashCode();
    return h$;
  }

  @Override
  public RouteProgress.Builder toBuilder() {
    return new Builder(this);
  }

  static final class Builder extends RouteProgress.Builder {
    private DirectionsRoute directionsRoute;
    private Integer legIndex;
    private Double distanceRemaining;
    private RouteLegProgress currentLegProgress;
    private List<Point> currentStepPoints;
    private List<Point> upcomingStepPoints;
    private Integer stepIndex;
    private Double legDistanceRemaining;
    private Double stepDistanceRemaining;
    private List<StepIntersection> intersections;
    private StepIntersection currentIntersection;
    private StepIntersection upcomingIntersection;
    private CurrentLegAnnotation currentLegAnnotation;
    private List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep;
    Builder() {
    }
    private Builder(RouteProgress source) {
      this.directionsRoute = source.directionsRoute();
      this.legIndex = source.legIndex();
      this.distanceRemaining = source.distanceRemaining();
      this.currentLegProgress = source.currentLegProgress();
      this.currentStepPoints = source.currentStepPoints();
      this.upcomingStepPoints = source.upcomingStepPoints();
      this.stepIndex = source.stepIndex();
      this.legDistanceRemaining = source.legDistanceRemaining();
      this.stepDistanceRemaining = source.stepDistanceRemaining();
      this.intersections = source.intersections();
      this.currentIntersection = source.currentIntersection();
      this.upcomingIntersection = source.upcomingIntersection();
      this.currentLegAnnotation = source.currentLegAnnotation();
      this.intersectionDistancesAlongStep = source.intersectionDistancesAlongStep();
    }
    @Override
    public RouteProgress.Builder directionsRoute(DirectionsRoute directionsRoute) {
      if (directionsRoute == null) {
        throw new NullPointerException("Null directionsRoute");
      }
      this.directionsRoute = directionsRoute;
      return this;
    }
    @Override
    DirectionsRoute directionsRoute() {
      if (directionsRoute == null) {
        throw new IllegalStateException("Property \"directionsRoute\" has not been set");
      }
      return directionsRoute;
    }
    @Override
    public RouteProgress.Builder legIndex(int legIndex) {
      this.legIndex = legIndex;
      return this;
    }
    @Override
    int legIndex() {
      if (legIndex == null) {
        throw new IllegalStateException("Property \"legIndex\" has not been set");
      }
      return legIndex;
    }
    @Override
    public RouteProgress.Builder distanceRemaining(double distanceRemaining) {
      this.distanceRemaining = distanceRemaining;
      return this;
    }
    @Override
    RouteProgress.Builder currentLegProgress(RouteLegProgress currentLegProgress) {
      if (currentLegProgress == null) {
        throw new NullPointerException("Null currentLegProgress");
      }
      this.currentLegProgress = currentLegProgress;
      return this;
    }
    @Override
    public RouteProgress.Builder currentStepPoints(List<Point> currentStepPoints) {
      if (currentStepPoints == null) {
        throw new NullPointerException("Null currentStepPoints");
      }
      this.currentStepPoints = currentStepPoints;
      return this;
    }
    @Override
    List<Point> currentStepPoints() {
      if (currentStepPoints == null) {
        throw new IllegalStateException("Property \"currentStepPoints\" has not been set");
      }
      return currentStepPoints;
    }
    @Override
    public RouteProgress.Builder upcomingStepPoints(@Nullable List<Point> upcomingStepPoints) {
      this.upcomingStepPoints = upcomingStepPoints;
      return this;
    }
    @Override
    @Nullable List<Point> upcomingStepPoints() {
      return upcomingStepPoints;
    }
    @Override
    public RouteProgress.Builder stepIndex(int stepIndex) {
      this.stepIndex = stepIndex;
      return this;
    }
    @Override
    int stepIndex() {
      if (stepIndex == null) {
        throw new IllegalStateException("Property \"stepIndex\" has not been set");
      }
      return stepIndex;
    }
    @Override
    public RouteProgress.Builder legDistanceRemaining(double legDistanceRemaining) {
      this.legDistanceRemaining = legDistanceRemaining;
      return this;
    }
    @Override
    double legDistanceRemaining() {
      if (legDistanceRemaining == null) {
        throw new IllegalStateException("Property \"legDistanceRemaining\" has not been set");
      }
      return legDistanceRemaining;
    }
    @Override
    public RouteProgress.Builder stepDistanceRemaining(double stepDistanceRemaining) {
      this.stepDistanceRemaining = stepDistanceRemaining;
      return this;
    }
    @Override
    double stepDistanceRemaining() {
      if (stepDistanceRemaining == null) {
        throw new IllegalStateException("Property \"stepDistanceRemaining\" has not been set");
      }
      return stepDistanceRemaining;
    }
    @Override
    public RouteProgress.Builder intersections(List<StepIntersection> intersections) {
      if (intersections == null) {
        throw new NullPointerException("Null intersections");
      }
      this.intersections = intersections;
      return this;
    }
    @Override
    List<StepIntersection> intersections() {
      if (intersections == null) {
        throw new IllegalStateException("Property \"intersections\" has not been set");
      }
      return intersections;
    }
    @Override
    public RouteProgress.Builder currentIntersection(StepIntersection currentIntersection) {
      if (currentIntersection == null) {
        throw new NullPointerException("Null currentIntersection");
      }
      this.currentIntersection = currentIntersection;
      return this;
    }
    @Override
    StepIntersection currentIntersection() {
      if (currentIntersection == null) {
        throw new IllegalStateException("Property \"currentIntersection\" has not been set");
      }
      return currentIntersection;
    }
    @Override
    public RouteProgress.Builder upcomingIntersection(@Nullable StepIntersection upcomingIntersection) {
      this.upcomingIntersection = upcomingIntersection;
      return this;
    }
    @Override
    @Nullable StepIntersection upcomingIntersection() {
      return upcomingIntersection;
    }
    @Override
    public RouteProgress.Builder currentLegAnnotation(@Nullable CurrentLegAnnotation currentLegAnnotation) {
      this.currentLegAnnotation = currentLegAnnotation;
      return this;
    }
    @Override
    @Nullable CurrentLegAnnotation currentLegAnnotation() {
      return currentLegAnnotation;
    }
    @Override
    public RouteProgress.Builder intersectionDistancesAlongStep(List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep) {
      if (intersectionDistancesAlongStep == null) {
        throw new NullPointerException("Null intersectionDistancesAlongStep");
      }
      this.intersectionDistancesAlongStep = intersectionDistancesAlongStep;
      return this;
    }
    @Override
    List<Pair<StepIntersection, Double>> intersectionDistancesAlongStep() {
      if (intersectionDistancesAlongStep == null) {
        throw new IllegalStateException("Property \"intersectionDistancesAlongStep\" has not been set");
      }
      return intersectionDistancesAlongStep;
    }
    @Override
    RouteProgress autoBuild() {
      String missing = "";
      if (this.directionsRoute == null) {
        missing += " directionsRoute";
      }
      if (this.legIndex == null) {
        missing += " legIndex";
      }
      if (this.distanceRemaining == null) {
        missing += " distanceRemaining";
      }
      if (this.currentLegProgress == null) {
        missing += " currentLegProgress";
      }
      if (this.currentStepPoints == null) {
        missing += " currentStepPoints";
      }
      if (this.stepIndex == null) {
        missing += " stepIndex";
      }
      if (this.legDistanceRemaining == null) {
        missing += " legDistanceRemaining";
      }
      if (this.stepDistanceRemaining == null) {
        missing += " stepDistanceRemaining";
      }
      if (this.intersections == null) {
        missing += " intersections";
      }
      if (this.currentIntersection == null) {
        missing += " currentIntersection";
      }
      if (this.intersectionDistancesAlongStep == null) {
        missing += " intersectionDistancesAlongStep";
      }
      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new AutoValue_RouteProgress(
          this.directionsRoute,
          this.legIndex,
          this.distanceRemaining,
          this.currentLegProgress,
          this.currentStepPoints,
          this.upcomingStepPoints,
          this.stepIndex,
          this.legDistanceRemaining,
          this.stepDistanceRemaining,
          this.intersections,
          this.currentIntersection,
          this.upcomingIntersection,
          this.currentLegAnnotation,
          this.intersectionDistancesAlongStep);
    }
  }

}
